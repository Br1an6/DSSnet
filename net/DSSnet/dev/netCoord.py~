#!usr/bin/python

##########################
#  channon@hawk.iit.edu  #
##########################

# DSSnet
# version 2.0

#####################
#  Mininet Imports  #
##################### 

from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import CPULimitedHost, Controller, OVSKernelSwitch, RemoteController, Host
from mininet.cli import CLI
from mininet.link import TCLink
from mininet.util import irange, dumpNodeConnections
from mininet.log import setLogLevel, info

####################
#  System Imports  #
####################

import sys
import time
import os
import subprocess
import zmq
import logging
import argparse
import thread
import heapq

# local

import DSSnet_handler as handler
import DSSnet_hosts

######################
#  Global Variables  #
###################### 

COORD_PIPE = 'tmp/coordination.pipe'
if not os.path.exists(COORD_PIPE):
    os.mkfifo(COORD_PIPE)

startTime=0.0

# parser

parser = argparse.ArgumentParser(description= 'Manages network emulation and synchronizes with the power Coordinator.')
parser.add_argument('--version', action='version', version='DSSnet 2.0')
parser.add_argument('--ip', help='ip of power coordinator', default='10.47.142.26', type=str)
parser.add_argument('--port', help='port of the power coordinator, default/recommended: 50021', default='50021', type=str)
parser.add_argument('--topo_config', help='path to topology file', type=str)
parser.add_argument('--IED_config', help='path to IED file', type=str)
parser.add_argument('--sync_event_log', help='path to logging file for synchronization events', default='logs/synch_event.log', type=str)
parser.add_argument('--window_size', help='maximum synchonization time(ms) for blocking events. see docs for more info', default = 0, type=int)



logging.basicConfig(filename=sync_event_log,level=logging.DEBUG)

# open transport layer to power coordinator
# TCP socket

contextOutDSS=zmq.Context()
DSSout=contextOutDSS.socket(zmq.REQ)
DSSout.connect("tcp://%s:%s" % (ip,port))

# Virtual time helpers

pIDS=' '

def pidList(net):
    for host in net.hosts:
        pIDS += ' %s' % host.pid
    for s in net.switches:
        pIDS += ' %s' % s.pid
    for c in net.controllers:
        pIDS += ' %s' % c.pid
    print ('pids in virtual time: %s' % pIDS)


NPAUSE  = ''
NRESUME = ''

def setupPause():
    global pIDS, NPAUSE, NRESUME
    NPAUSE  = 'sudo /home/vagrant/virtual/VirtualTimeKernel/test_virtual_time/freeze_all_procs -f -p %s'%pIDS
    NRESUME = 'sudo /home/vagrant/virtual/VirtualTimeKernel/test_virtual_time/freeze_all_procs -u -p %s'%pIDS

#
#  Interface to virtual time
#

    
def pause ():
    before_time = time.time()
    logging.info('pause time: %s'%before_time)
    process = subprocess.call(NPAUSE, shell=True)
    after_time = time.time()
    logging.info('\npause took: %s\n'% (after_time-before_time))


def resume ():
    before_time = time.time()
    logging.info('resume time: %s'%time.time())
    process = subprocess.call(NRESUME, shell=True)
    after_time = time.time()
    logging.info('\nresume took: %s\n'% (after_time-before_time))


#event Queue

eventQueue = []




    

# main event loop
#  waiting for sync event

num_block = 0 # used to determine if multiple blocking events are recieved before pausing can occur in order not to repeat the block

com_lock=thread.allocate_lock()


def pipe_listen (net):
    pipein = open(COORD_PIPE, 'r')
    global startTime
    global num_block
    global eventQueue
    while True:
        newEvent = pipeinreadline()[:-1] # trim newline character
        # if event has arrived
        if newEvent:
            event = line.split()
            if event[1] == 'b': # blocking
                num_block+=1
                pause()


            # add event to priority queue
            


            
            # sync new thread
            thread.start_new_thread(sync,newEvent)
            
def sync(newEvent):
    global num_block
    event = newEvent.split()
    try:
        preprocess=getattr(handle,event[3])
        processed_event=preprocess(newEvent)
    except AttributeError:
        print('pre-process error: %s' % newEvent)
        logging.info('pre-process error with event request %s' % newEvent)

    with com_lock: # mutual exclusivity is required with com
        reply = do_com(processed_event)
        
    try:
        postprocess=getattr(handle,event[4])
        processed_event=postprocess(newEvent,reply)
    except AttributeError:
        print('post process error:  %s' % newEvent)
        logging.info('post process error with event request: %s' % newEvent)

    if newEvent[1] == 'b':
        num_block -= 1
        if num_block == 0:
            unpause()

    thread.exit()


def do_com(request):
    req_bytes=request.encode('utf-8')
    DSSout.send(req_bytes)
    status=DSSout.recv()
    data = status.decode('utf-8')
    logging.info('reply recieved %s: ' % data)
    return data

hosts = []

class topo(Topo):
    "creates topology"

    def build(self):
        
        global hosts
        global IED_config
        global topo_config

        with open(IED_config, 'r') as ins:
            for line in ins:
                if line[0] != '#': # comment
                    # expecting a dssnet_host object format
                    properties = line.split(' split ') # wont interfere with command 
                    # msg id command
                    hosts.append(DSSnet_host(properties[1], properties[0], properties[3], properties[2]))
                    host = self.addHost(properties[0])

        with open(topo_config, 'r') as ins:
            for line in ins:
                if line[0] != '#':
                    elements = line.split()
                    if elements[0] == 'new' :
                        self.addSwitch(elements[1])
                    else:
                        self.addLink(elements[0],elements[1],**linkops)
                                                                    
def run_main():
    global hosts

    top = topo()
    net = Mininet(topo, link = TCLink)
    net.start()

    # set IP
    for i in hosts:
        net.get(i.get_host_name()).cmd('ifconfig %s-etho %s' % (i.get_host_name, i.get_ip))
    
    print('Dumping Host Connections')
    dumpNodeConnections(net.hosts)

    pidList(net)
    setupPause()
    # start commands
    for i in hosts:
        net.get(i.get_host_name()).cmd(i.get_process_command)

    global startTime
    startTime = time.time()
    print('initiation finished')
    pipeListen(net)

if __name__ == '__main__':
    setLogLevel('info')
    run_main()
